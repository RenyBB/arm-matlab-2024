<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>The assessment</title>
    <meta charset="utf-8" />
    <meta name="author" content="Lincoln Colling" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <script src="libs/peerjs-1.3.1/peerjs.min.js"></script>
    <script src="libs/tiny.toast-1.0.0/toast.min.js"></script>
    <link href="libs/xaringanExtra-broadcast-0.2.6/broadcast.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-broadcast-0.2.6/broadcast.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/animate.css-3.7.2/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons-4.12.0/tachyons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# The assessment
]
.subtitle[
## A few tips
]
.author[
### Lincoln Colling
]

---


&lt;!-- 
vim: set ft=markdown tw=80 spell spelllang=en_gb:
vim: set conceallevel=0 foldlevel=1:
--&gt;









# Outline

- Your task is to implement a computerized experiment task using Matlab.

- The recommended task is a standard Colour/Word Stroop task with *at least*
three colour words (e.g., blue, red, yellow). 

- However, if you'd like to design a task that is relevant to your Master's thesis
then you're also welcome to do so **if you check with me first**.


---

## Things to consider 

The aim is to develop a computerized task that is as realistic as possible.

This means that your task should:

- Have multiple trials (not just 3 or 4)

  - If your code is well-designed then it should be trivial to alter the number
    of trials for particular use cases

- You should consider things like trial order

- You should think about how the data is saved and **what data** is saved

Programming is not just about writing code. It's about *designing* your code
so that your code can *achieve your objective*.

This means that **most** of the assignment will be about **designing** your
code. Only after you've planned out exactly what *your code will do* should you
start writing code.

*The [assessment page](../../assessment.html#things-to-consider) has more
information about the sorts of things you should be thinking about when you're
designing your code* 

---

## How it will be assessed

You will be assessed on the quality of your code... What does this mean?

- First and foremost, this means that **your code should run**

However, I will also be looking at other things

- Do you write your code in such a way so that you make use of *reusable
  components* that could, in theory, be used as part of different experiment

- Do you include documentation for reusable functions that you write, so that,
  for example, other members of your lab could make use of them

- Does your code save files in a sensible way

- Does your code save all the information you'll need to analyze the data for
  your experiment

I won't give you a bullet point list of everything that your code needs to do,
because thinking about the *design of your code* **is the task YOU need to
solve**


&lt;!-- ## The task

The task should be as realistic as possible. This means that it should include:

- Multiple trials 


- Should record some kind of response

Additionally, it should save the data from the experiment. This data should be
saved in a way that would allow it to be analyzed later. E.g., if you record
responses, these should be matched with a stimulus/condition 
--&gt;
---

### What you need to submit

You'll need to include the following things with your submission.

1. The `Matlab` code for your task

  - This might be one file, or it might be multiple files (for example if you
    decided to employ multiple functions) 

  - Please ensure **that your code runs**, because I will be running it!

2. Data from one participant (yourself), so that I can see what the output
   looks like

3. A description of the task:

  - What kind of task is it
  
  - What are the different conditions
  
  - What responses are being recorded / why?

I expect this *description* to be fewer than 750 words. The purpose of this
description is so that I can make sure that your code *does what you
intend it to do*.

---
  
### What you need to submit
  
- The submission will take the form of a word/pdf document with your description
  and one or more `.m` files with the actual `Matlab` code.

- You **must** zip these together in a `.zip` file because **canvas** renames
  uploaded files so uploading the files individually will break things and it 
  will make it impossible for me to run the code!


---

### Getting help

Peter Scarfeâ€™s PsychToolbox Demos provide lots of good examples of using
PsychToolbox.

Note, however, that these are designed as **demos** so _please_ don't just copy
one of the examples and submit that as your assessment, because these don't do
everything that _your code will need to do_ (e.g., they don't have very good
participant instructions, and they don't save the data in a useful way etc)

This website, together with the stuff that was covered in class will give you
all the building blocks you need to put together an experiment.

You'll still need to put those blocks together, but you can make use of any 
resources you can find.

---

### Finally

**Keep things simple** but **do the simple things well**

Trying to overcomplicate things is always risky, so try to avoid it.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
